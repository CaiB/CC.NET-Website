var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(n){const s=suggestions.classList.contains("d-none");if(s)return;const e=[...suggestions.querySelectorAll("a")];if(e.length===0)return;const t=e.indexOf(document.activeElement);if(n.key==="ArrowUp"){n.preventDefault();const s=t>0?t-1:0;e[s].focus()}else if(n.key==="ArrowDown"){n.preventDefault();const s=t+1<e.length?t+1:t;e[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/sources/",title:"Sources",description:"",content:""}),e.add({id:1,href:"/docs/general/gettingstarted/",title:"Getting Started",description:"ColorChord.NET requires a little bit of configuration, but it's worth it!",content:"Thanks for taking the time to check out ColorChord.NET. I hope you enjoy it, and please feel free to let me know if you encounter any issues or have any feedback. One way is to open an issue on GitHub.\nInstallation # .NET Desktop Runtime # The .NET Desktop Runtime is needed in order to run ColorChord.NET. Currently, ColorChord.NET is built against .NET 7. There are 2 versions: The .NET Desktop Runtime, which is required, and the .NET SDK, which is larger, and is only needed if you want to develop .NET software. The SDK includes the Runtime as well.\nYou can download the .NET 7 Desktop Runtime from Microsoft here, it works on Windows, Linux, and macOS:\nDownload .NET Desktop Runtime\nVisual C++ Runtime # It is very likely you already have this installed on your computer, because many different applications rely on it. If you do get an error about a missing DLL, please install the Microsoft Visual C++ Redistributable. You can get the x64 version from here (most likely what you need), or the ARM64 version from here (applicable only to some newer tablets/laptops).\nColorChord.NET # Once you have the .NET Runtime installed, you\u0026rsquo;ll need to download ColorChord.NET. You will have 2 choices:\n Autobuild: This contains the latest under-development additions, changes, and bugfixes. However it may not be stable or ready for general use yet. Release: This contains a reasonably stable build, without the bleeding-edge development work.  Choose one, then expand the \u0026ldquo;Assets\u0026rdquo; section, and download the .ZIP file (not the source code) from GitHub below:\nDownload ColorChord.NET\nInstalling ColorChord.NET is simple.\n Extract the .zip file to a convenient location (e.g. Your user account\u0026rsquo;s Documents) Start the application, depending on your platform:\na) Windows: Double-click on ColorChord.NET.exe\nb) Linux: Run \u0026ldquo;dotnet ColorChord.NET.dll\u0026rdquo; On first run, it will auto-generate the default config.json file. Exit ColorChord.NET. Edit the config file to suit your needs (see below). Run ColorChord.NET again after editing the config, check the console for any warnings or errors, and enjoy!  Configuration # How it Works # There are 5 types of components in ColorChord.NET:\n Audio Sources: Brings audio data from your system into ColorChord.NET. If you\u0026rsquo;re on Linux, you\u0026rsquo;ll likely want to use Note Finder: Turns raw audio data into note information. Visualizers: Takes note info from the Note Finder, and transforms it into something interesting to look at, ready for output. Outputs: Takes data from a visualizer, and actually displays/outputs it somewhere. Controllers: Edits the behaviour of any of the above components while ColorChord.NET is running.  A single instance of the application supports a single audio source and Note Finder, any number of visualizers, each with its own set of (any number of) outputs. This allows for a single audio stream to be processed and displayed in almost any desired combination of ways.\nControllability # Many components in ColorChord.NET have \u0026ldquo;controllable\u0026rdquo; config options, as seen in the tables in this documentation. This does not refer to whether you can change the setting in the config file (anything that is listed in the docs can be changed by you), but rather refers to whether a controller component is able to change this setting while ColorChord.NET is already running.\nConfig File Notes #  You can see a sample config file here. This is what the program auto-generates if no config is found. If an option is not specified in the configuration file, the default value is used. If an unrecognized option or invalid value is specified, a warning is output to the console. Always check for these after modifying the config in case you made a spelling mistake. You can choose a different configuration file by running the program with the command line option \u0026ldquo;config YourFile.json\u0026rdquo;. Range specifies the set of input values that can be used. Extreme values may not make any sense in practice though, so make small changes from the defaults to start. Range is just specified to prevent completely invalid input.  "}),e.add({id:2,href:"/docs/general/importconfig/",title:"Import Config from ColorChord",description:"A cnlohr ColorChord configuration file can be converted to a ColorChord.NET configuration with a bit of manual work.",content:"There currently is no automatic way to convert a config file, due to the difference in functionality.\nThe parameters for almost everything in ColorChord.NET are backwards-compatible with cnlohr\u0026rsquo;s ColorChord, so you can usually copy the values. If there is a difference, it should be noted in the relevant section for the component.\nIf you want to replicate an existing setup, start with the default config.json file, and copy parameters over to my format one-by-one, finding the appropriate place to put them.\nI try to maintain the same behaviour given the same inputs as cnlohr\u0026rsquo;s version. If you notice an undocumented difference, please let me know.\nName Conversions #  cnlohr ColorChord Name ColorChord.NET Component ColorChord.NET Name     base_hz NoteFinder StartFreq   dft_iir NoteFinder DFTIIR   amplify NoteFinder DFTAmplify   slope NoteFinder DFTSlope   filter_iter NoteFinder OctaveFilterIterations   filter_strength NoteFinder OctaveFilterStrength   note_jumpability NoteFinder NoteInfluenceDist   note_attach_freq_iir NoteFinder NoteAttachFreqIIR   note_attach_amp_iir NoteFinder NoteAttachAmpIIR   note_attach_amp_iir2 NoteFinder NoteAttachAmpIIR2   note_combine_distance NoteFinder NoteCombineDistance   note_out_chop NoteFinder NoteOutputChop   leds Visualizer: Cells, Linear LEDCount   led_floor Visualizer: Linear LEDFloor   light_siding Visualizer: Cells, Linear LightSiding   satamp Visualizer: Cells, Linear SaturationAmplifier   qtyamp Visualizer: Cells QtyAmp   seady_brightsteady_bright Visualizer: Cells, Linear SteadyBright   timebased Visualizer: Cells TimeBased   snakey Visualizer: Cells Snakey   is_loop Visualizer: Linear IsCircular   led_limit Visualizer: Linear LEDLimit   skipfirst Output: PacketUDP/Raw PaddingFront   firstval Output: PacketUDP/Raw PaddingContent   "}),e.add({id:3,href:"/docs/general/openrgb/",title:"Use with OpenRGB",description:"ColorChord.NET can be used with OpenRGB to control PC components and peripherals with RGB LEDs.",content:"Currently the easiest way to pipe data from ColorChord.NET into OpenRGB is via E1.31 packets. These instructions will help you set up everything you need.\nI have only tested this on Windows, but it theoretically should work on Linux as well.\nInstall \u0026amp; Configure OpenRGB # Download OpenRGB Download E1.31 Plugin\n Start by downloading OpenRGB and the E1.31 Receiver Plugin for your system from the above links.\na) For the plugin, click the newest passing build\u0026rsquo;s pipeline number, select your platform, then click \u0026ldquo;Download Job Artifacts\u0026rdquo; on the right. For Windows, unzip the main package to a convenient location, such as C:\\Program Files\\OpenRGB. For Linux, follow the install instructions here. On Windows, run OpenRGB as administrator (this is only needed the first time). Once it has opened, close it. Install the E1.31 receiver plugin:\na) For Windows, copy the DLL file from the archive you downloaded to %APPDATA%/OpenRGB/plugins.\nb) For Linux, copy the SO file from the archive you downloaded to ~/.config/OpenRGB/plugins. Start OpenRGB. You should see a \u0026ldquo;E1.31 Receiver\u0026rdquo; tab in the GUI. On the \u0026ldquo;Devices\u0026rdquo; tab, select the devices you\u0026rsquo;d like to configure. For each, change the mode to \u0026ldquo;Direct\u0026rdquo;. On the \u0026ldquo;E1.31 Receiver\u0026rdquo; tab, click \u0026ldquo;Add Universe\u0026rdquo;. Click the newly added universe in the right pane, then click the device you\u0026rsquo;d like to control from the left pane. With both selected, click \u0026ldquo;Add Controller\u0026rdquo;. To be able to read the universe number, you may have to enlarge the window. Adjust the Start Channel, Start LED, and End LED if necessary, and repeat for all of your devices. If you want a group of devices to follow the same lighting pattern, put them in the same universe. Click \u0026ldquo;Start Receiver\u0026rdquo; and allow OpenRGB through the firewall if necessary.  Install \u0026amp; Configure ColorChord.NET # Set Up ColorChord.NET\n Follow the instructions in the Getting Started guide to install ColorChord.NET. Add or edit an output to be of type PacketUDP. Apply the following settings in the ColorChord.NET config.json:  \u0026quot;Type\u0026quot;: \u0026quot;PacketUDP\u0026quot;, \u0026quot;Name\u0026quot;: \u0026quot;CC.NET to OpenRGB\u0026quot;, \u0026quot;VisualizerName\u0026quot;: \u0026quot;NameHere\u0026quot;, \u0026quot;IP\u0026quot;: \u0026quot;127.0.0.1\u0026quot;, \u0026quot;Port\u0026quot;: 5568, \u0026quot;Protocol\u0026quot;: \u0026quot;E1.31\u0026quot;, \u0026quot;Universe\u0026quot;: 1, \u0026quot;Enable\u0026quot;: true  Make sure to replace the VisualizerName entry with your visualizer instance name, and replace Universe with the universe number that OpenRGB is expecting. Start ColorChord.NET, verify there are no config issues in the console, and check to make sure the \u0026ldquo;Packets Received\u0026rdquo; number is increasing in OpenRGB. Your device should now be lighting up with ColorChord.NET! As this is a network output, the computer on which ColorChord.NET is running does not have to be the same computer as OpenRGB is running. You can also control OpenRGB across multiple computers, by simply adding more PacketUDP entries in the ColorChord.NET config, and changing the options as appropriate for each one. Musticast should also work to simultaneously send to multiple receivers.  "}),e.add({id:4,href:"/docs/sources/wasapiloopback/",title:"WASAPILoopback",description:"Modern Windows audio interface, supports both inputs and loopback.",content:'The Windows Audio Session API is the recommended way of sourcing low-latency audio data on Windows 7 and later systems. It supports both input devices (such as microphones), and output devices (loopback from speaker output).\nSource Code. Uses Vannatech\u0026rsquo;s netcoreaudio.\nConfiguration #  Option Name Type Default Range Description     Device string "default" "default",\n"defaultInput",\n"defaultTracking",\nDevice IDs If "default", then the default render (output) device at the time of startup will be used.\nIf "defaultInput", then the default capture (input) device at the time of startup will be used.\nIf "defaultTracking", the default device will be used, and will keep up with changes to the default, switching as the system does (not yet implemented).\nIf a device ID is specified, that device is used, but if it is not found, then behaviour reverts to "default".   ShowDeviceInfo bool true  If true, outputs currently connected devices and their IDs at startup, to help you find a device.    Device IDs # Device IDs are unique for each device on the system, vary between different computers, and only change if drivers are updated/changed. Removal and re-attachment of a USB device will not change the ID. They are not readily visible to the user, but other software using WASAPI will have access to the same IDs. Use ShowDeviceInfo (above) to find the ID for your preferred device. Output format is:\n[Index] \u0026quot;Device Name\u0026quot; = \u0026quot;Device ID\u0026quot;  (Index is not used, it is just present to make the list easier to read)\n'}),e.add({id:5,href:"/docs/sources/cnfabinding/",title:"CNFABinding",description:"Uses cnlohr's CNFA for compatibility with non-Windows platforms.",content:'CNFA provides compatibility with a variety of different audio systems on various platforms. It is currently the only supported method of receiving audio on Linux. On Windows, WASAPILoopback is recommended instead.\nSource Code\nConfiguration #  Option Name Type Default Range Description     Driver string "AUTO" "AUTO", "ALSA", "ANDROID", "NULL", "PULSE", "WASAPI", "WIN" Determines which CNFA driver module will be used. If "AUTO" is specified, it will attempt to find the best driver for your system.   SampleRate int 48000 8000~384000 Suggests a sample rate to the driver.   ChannelCount int 2 1~20 Suggests a channel count to the driver.   BufferSize int 480 1~10000 Suggests a buffer size to the driver.   Device string "default" Valid device names / keywords The recording device to use. This depends on the driver. Please check CNFA documentation for the driver you want to use to determine what should be used here.   DeviceOutput string "default" Valid device names / keywords The output device to use. This device is not actually used, as ColorChord.NET does not play audio.   '}),e.add({id:6,href:"/docs/notefinder/basenotefinder/",title:"NoteFinder",description:"The module that takes audio data and converts it to note information.",content:"There currently is only one NoteFinder, with the same behaviour as the one in base ColorChord.\nSource Code\nConfiguration #    Option Name Type Default Range Controllable Description     StartFreq float 65.4064 0.0~20000.0 ✅ The minimum frequency analyzed. (in Hz) ℹ️ See note below.   DFTIIR float 0.65 0.0~1.0 ✅ Determines how much the previous frame\u0026rsquo;s DFT data is used in the next frame. Smooths out rapid changes from frame-to-frame, but can cause delay if too strong.   DFTAmplify float 2.0 0.0~10000.0 ✅ Determines how much the raw DFT data is amplified before being used.   DFTSlope float 0.1 0.0~10000.0 ✅ The slope of the extra frequency-dependent amplification done to raw DFT data. Positive values increase sensitivity at higher frequencies.   OctaveFilterIterations int 2 0~10000 ✅ How often to run the octave data filter. This smoothes out each bin with adjacent ones.   OctaveFilterStrength float 0.5 0.0~1.0 ✅ How strong the octave data filter is. Higher values mean each bin is more aggressively averaged with adjacent bins. Higher values mean less glitchy, but also less clear note peaks.   NoteInfluenceDist float 1.8 0.0~100.0 ✅ How close a note needs to be to a distribution peak in order to be merged.   NoteAttachFreqIIR float 0.3 0.0~1.0 ✅ How strongly the note merging filter affects the note frequency. Stronger filter means notes take longer to shift positions to move together.   NoteAttachAmpIIR float 0.35 0.0~1.0 ✅ How strongly the note merging filter affects the note amplitude. Stronger filter means notes take longer to merge fully in amplitude.   NoteAttachAmpIIR2 float 0.25 0.0~1.0 ✅ This filter is applied to notes between cycles in order to smooth their amplitudes over time.   NoteCombineDistance float 0.5 0.0~100.0 ✅ How close two existing notes need to be in order to get combined into a single note.   NoteOutputChop float 0.05 0.0~1.0 ✅ Notes below this value get zeroed. Increase if low-amplitude notes are causing noise in output.    ℹ️  The default configuration of StartFreq is different than cnlohr's implementation. If you want behaviour to match with his default configurations, change StartFreq to 55.0.   "}),e.add({id:7,href:"/docs/visualizers/linear/",title:"Linear",description:"Shows contiguous blocks of colour, size corresponding to relative note volume, and with inter-frame continuity.",content:"Output Modes: Discrete 1D, Continuous 1D\nSource Code\nConfiguration #    Option Name Type Default Range Controllable Description     Type string  \u0026ldquo;Linear\u0026rdquo; ❌ Required: Specifies this visualizer type.   Name string  Any unique name ❌ Required: A unique identifier used to attach outputs and controllers.   LEDCount int 50 1~100000 ✅ The number of discrete data points to output. Set this to a low value like 24 if only continuous output is used to save CPU time.   FrameRate int 60 0~1000 ✅ The number of data frames to attempt to calculate per second. Determines how fast the data is output.   LEDFloor float 0.1 0.0~1.0 ✅ The minimum intensity of an LED, before it is output as off instead.   LightSiding float 1.0 0.0~100.0 ✅ How strongly inputs should be amplified before processing. Exponential.   SaturationAmplifier float 2.0 0.0~100.0 ✅ Multiplier for colour saturation before conversion to RGB and output.   IsCircular bool false  ✅ Whether to treat the output as a circle, allowing wrap-around, or as a line with defined ends. ℹ️ See below note.   IsOrdered bool false  ✅ Whether notes should be ordered by their colour, or choose locations semi-randomly.   SteadyBright bool false  ✅ Smoothes LED brightness to reduce flickering.   LEDLimit float 1.0 0.0~1.0 ✅ The maximum LED brightness. Caps all LEDs at this value, but does not affect values below this threshold.   Enable bool true  ✅ Whether to use this visualizer.    ℹ️  IsCircular=true in continuous mode does not match the behaviour of base ColorChord, as it uses a different, custom algorithm for positioning. However, discrete mode should match the base version.\nIsCircular=false should match base ColorChord in both continuous and discrete mode.   "}),e.add({id:8,href:"/docs/visualizers/cells/",title:"Cells",description:"Shows individual LEDs appearing and decaying, in a scattered pattern depending on surroundings and time.",content:"Output Modes: Discrete 1D\nSource Code\nConfiguration #    Option Name Type Default Range Controllable Description     Type string  \u0026ldquo;Cells\u0026rdquo; ❌ Required: Specifies this visualizer type.   Name string  Any unique name ❌ Required: A unique identifier used to attach outputs and controllers.   LEDCount int 50 1~100000 ✅ The number of discrete data points to output.   FrameRate int 60 0~1000 ✅ The number of data frames to attempt to calculate per second. Determines how fast the data is output.   LightSiding float 1.9 0.0~100.0 ✅ How strongly inputs should be amplified before processing. Exponential.   SaturationAmplifier float 2.0 0.0~100.0 ✅ Multiplier for colour saturation before conversion to RGB and output.   QtyAmp float 20 0.0~100.0 ✅ Multiplier for LED quantity to turn on for the same input. Scale this with LED quantity.   SteadyBright bool false  ✅ Smoothes LED brightness to reduce flickering.   TimeBased bool false  ✅ Whether lights get added from the left side creating a time-dependent decay pattern, or are added randomly.   Snakey bool false  ❌ Currently does nothing, like in cnlohr\u0026rsquo;s ColorChord.   Enable bool true  ✅ Whether to use this visualizer.    "}),e.add({id:9,href:"/docs/visualizers/voronoi/",title:"Voronoi",description:"Shows blobs of colour, size corresponding to relative note volume, and with inter-frame continuity.",content:"Output Mode: Discrete 2D\nSource Code\nConfiguration #    Option Name Type Default Range Controllable Description     Type string  \u0026ldquo;Voronoi\u0026rdquo; ❌ Required: Specifies this visualizer type.   Name string  Any unique name ❌ Required: A unique identifier used to attach outputs and controllers.   LEDCountX int 64 1~100000 ✅ The pixel count in the X dimension to output.   LEDCountY int 32 1~100000 ✅ The pixel count in the Y dimension to output.   FrameRate int 60 0~1000 ✅ The number of data frames to attempt to calculate per second. Determines how fast the data is output.   AmplifyPower float 2.51 0.0~100.0 ✅ The power to raise note amplitudes to in preprocessing. Larger values create a bigger difference in size between strong and weak notes.   DistancePower float 1.5 0.0~100.0 ✅ How far to draw colours from the blob center. Higher numbers means fewer individual colours will take up the majority of screen space.   Cutoff float 0.03 0.0~100.0 ✅ Notes below this threshold do not get considered when rendering.   CentersFromSides bool true  ✅ Whether to draw the blobs around the screen in a predefined circular pattern (true), or to randomly place them on the screen (false).   SaturationAmplifier float 5.0 0.0~100.0 ✅ Amplifier for output colour saturation from note amplitude.   OutputGamma float 1.0 0.0~1.0 ✅ Scales the output saturation curve.   Enable bool true  ✅ Whether to use this visualizer.    "}),e.add({id:10,href:"/docs/visualizers/prominent/",title:"Prominent",description:"Shows a single colour of the most prominent note.",content:"Output Modes: Discrete 1D\nSource Code\nConfiguration #    Option Name Type Default Range Controllable Description     Type string  \u0026ldquo;Prominent\u0026rdquo; ❌ Required: Specifies this visualizer type.   Name string  Any unique name ❌ Required: A unique identifier used to attach outputs and controllers.   LEDCount int 50 1~100000 ✅ The number of discrete data points to output. All LEDs will be set to the same colour.   FrameRate int 60 0~1000 ✅ The number of data frames to attempt to calculate per second. Determines how fast the data is output.   SaturationAmplifier float 2.0 0.0~100.0 ✅ Multiplier for colour saturation before conversion to RGB and output.   Enable bool true  ✅ Whether to use this visualizer.    "}),e.add({id:11,href:"/docs/visualizers/mmapreceiver/",title:"MemoryMapReceiver (For Debugging)",description:"Reads from an existing memory-mapped file using an existing mutex. Intended for testing only, or as a reference implementation.",content:'Output Modes: Discrete 1D\nSource Code\nConfiguration #  Option Name Type Default Range Description     Type string  "MemoryMapReceiver" Required: Specifies this visualizer type.   Name string  Any unique name Required: A unique identifier used to attach outputs and controllers.   MapName string N/A Valid memory map name The name of the memory-mapped file to read data from. The MemoryMap output will create a file by name ColorChord.NET-[OutputName] where [OutputName] is the Name configuration parameter on the Output instance.   MutexName string N/A Valid mutex name The name of the mutex to interface with. The MemoryMap output will create a mutex by name ColorChord.NET-Mutex-[OutputName] where [OutputName] is the Name configuration parameter on the Output instance.   FrameRate int 60 0~1000 The number of data frames to attempt to read per second. Determines how fast the data is output.   '}),e.add({id:12,href:"/docs/visualizers/udpreceiver1d/",title:"UDPReceiver1D (For Debugging)",description:"Takes in UDP packets, and outputs them as if the data were locally calculated. Does not actually use the sources or NoteFinder in this instance. Rate and size is determined by input packets.",content:'Output Modes: Discrete 1D\nSource Code\nConfiguration #  Option Name Type Default Range Description     Type string  "UDPReceiver1D" Required: Specifies this visualizer type.   Name string  Any unique name Required: A unique identifier used to attach outputs and controllers.   HasYellowChannel bool false  Whether to interpret packets as RGB (false) or RGBY (true).   Port int 7777 0~65535 The port to listen on for UDP packets.    ℹ️  Make sure your firewall settings allow ColorChord.NET to receive UDP packets.   '}),e.add({id:13,href:"/docs/outputs/displayopengl/",title:"DisplayOpenGL",description:"Uses OpenGL to render graphics to a window on the screen in various modes.",content:"Source Code\nModes Overview #  BlockStrip: Shows blocks of colour, similar to an LED strip, with the number of blocks controlled by the attached visualizer. SmoothStrip: Shows contiguous blocks of colour, with no resolution limit. BlockMatrix: Shows blocks of colour on a 2D field, with resolution controlled by the attached visualizer. SmoothCircle: Shows a ring of contiguous colour blocks. Optionally fades past colours away to infinity. Radar: Shows a scanning circular display, with the newest colours being shown at the revolving marker. SmoothRadialFilled: Highlights the currently active part of a static colour spectrum. RadialPoles: Shows coloured poles sticking out from the center of the screen, with dynamic height. ColorRibbon: Shows a dynamic flying ribbon of colour trailing off into space, surrounded by a field of stars. NoiseField: Fills the screen with very chaotic procedural noise, shaded with note data. CloudChamber: Shows radial laser beams. Tube: (Experimental) Renders a moving tube which reacts to the beat and notes of the music.  Window Configuration #    Option Name Type Default Range Controllable Description     Type string  \u0026ldquo;DisplayOpenGL\u0026rdquo; ❌ Required: Specifies this output type.   Name string  Any unique name ❌ Required: A unique identifier used to attach controllers.   VisualizerName string  Valid visualizer instance name ❌ Required: The Name property of the visualizer instance to attach to.   WindowWidth int 1280 10~4000 ✅ The starting width of the window, in pixels.   WindowHeight int 720 10~4000 ✅ The starting height of the window, in pixels.   Enable bool true  ✅ Whether to show the window and process visualizer data.   Mode object array N/A Valid modes ❌ The mode(s) to use. See below for options and configurations. Currently only 1 supported at a time.    Mode Information / Configurations # Display modes are not controllable yet.\nBlockStrip # Input Mode: Discrete 1D\nSource Code\nNumber of blocks displayed adjusts to match the attached visualizer.\nNo additional configuration is available.\nSmoothStrip # Input Mode: Continuous 1D\nSource Code\nNo additional configuration is available.\nBlockMatrix # Input Mode: Discrete 2D\nSource Code\n2D version of BlockStrip. Resolution displayed adjusts to match the attached visualizer.\nNo additional configuration is available.\nSmoothCircle (\u0026ldquo;Infinity Circle\u0026rdquo;) # Input Mode: Continuous 1D\nSource Code\n   Option Name Type Default Range Description     IsInfinity bool false  false just renders the ring. true also renders a decaying persistence effect, appearing to go off to infinity.    Radar # Input Mode: Discrete 1D\nSource Code\nSpoke resolution (number of segments) is determined by the resolution of the attached visualizer.\n   Option Name Type Default Range Description     Spokes int 100 1~10,000 How many spokes (history length / radial lines) there are. Higher shows more history.   Is3D bool false  Whether to show a height-variable, tilted-view version with beats causing vertical deflection of the surface.   FalloffAfter float 0.9 0.0~1.0 How much of the radar is shown at full brightness, after which the rest has a gradient to black applied, ending in front of the \u0026ldquo;cursor\u0026rdquo;.    SmoothRadialFilled (\u0026ldquo;Circle Beamer\u0026rdquo;) # Input Modes: Any\nSource Code\nDoes not use the attached visualizer, but rather shows NoteFinder data directly.\n   Option Name Type Default Range Description     BaseBrightness float 0.0 0.0~1.0 How bright colours should be if there is no note at that location. Values greater than 0.0 show a ghost of the colour wheel at all times.   PeakWidth float 0.5 0.0~10.0 How wide peaks should be.   BrightAmp float 1.0 0.0~100.0 How much brightness should be amplified. If peak width is increased, you may want to increase this as well, and vice versa.    RadialPoles # Input Modes: Any\nSource Code\nDoes not use the attached visualizer, but rather shows NoteFinder data directly.\n   Option Name Type Default Range Description     CenterSize float 0.2 0.0~1.0 How much of the center is left blank before the poles begin. 0 leaves no gap at the center.   ScaleExponent float 1.6 0.0~10.0 The exponent to scale note data by when calculating pole height.   ScaleFactor float 0.7 0.0~100.0 The multiplier to scale note data by when calculating pole height.    ColorRibbon # Input Mode: Discrete 1D\nSource Code\nDisplays a flying ribbon of colour trailing off into space, surrounded by a field of stars that also display colour. The ribbon grows and shrinks with note strength.\nBETA: The star rendering is still quite janky and needs more work to look good.\n   Option Name Type Default Range Description     RibbonLength int 120 2~10,000 How many frames of history the ribbon shows along its length.   RibbonScale float 0.3 0.0~100.0 The base width of the ribbon, which will be scaled by the music.   StarCount int 1000 0~100,000 How many stars are shown in the background.   StarSpeed float 0.1 0.0~100.0 How fast the stars in the background move away.   StarSize float 0.05 0.0~1.0 How large the stars appear.    NoiseField # Input Mode: Continuous 1D\nSource Code\nFills the screen with procedural noise, shading with the current notes. Amount of the screen that is a colour is roughly proportional to how prominent that note is. Also attempts to do basic beat detection, and change the noise size in time. Very chaotic, flashing lights warning applies even more to this one!\n   Option Name Type Default Range Description     Size1 float 8.0 0.0~10,000.0 Size scaling factor of the larger, beat-sensitive noise layer   Size2 float 3.5 0.0~10,000.0 Size scaling factor of the finer, constant noise layer   Speed float 5.0 0.0~10,000.0 How quickly the pattern appears to move up the screen    CloudChamber # Input Mode: Continuous 1D\nSource Code\nCurrently displays radial laser beams, unfinished.\nNo additional configuration is available.\nTube # Input Mode: Discrete 1D\nSource Code\nCircle resolution is determined by the resolution of the attached visualizer.\nYou can move around with the W, A, S, D, Shift, Space keys. You can look around using the arrow keys. This is still extremely janky.\nNo additional configuration is available.\n"}),e.add({id:14,href:"/docs/outputs/packetudp/",title:"PacketUDP",description:"Packs the data for each LED in sequence into a UDP packet, then sends it to a given IP/port.",content:"Input Modes: Discrete 1D\nSource Code\nℹ️  Individual packets have a size limit of 65,535 bytes. Each colour takes 1 byte.   Supported Protocols #  Raw: Outputs the LED data without any headers or packet splitting. Used by cnlohr\u0026rsquo;s ColorChord and most basic receivers. TPM2.net: Outputs data packets as per the TPM2.net spec, see here, and TPM2 info in German. Usable with WLED. Can split packets for many more LEDs. E1.31: Outputs the LED data in packets as per the E1.31 spec. Useful for DMX systems.  Common to all Protocols #    Option Name Type Default Range Controllable Description     Type string  \u0026ldquo;PacketUDP\u0026rdquo; ❌ Required: Specifies this output type.   Name string  Any unique name ❌ Required: A unique identifier used to attach controllers.   VisualizerName string  Valid visualizer instance name ❌ Required: The Name property of the visualizer instance to attach to.   Protocol string \u0026ldquo;Raw\u0026rdquo; Supported protocols from list above ❌ Determines how packets are formatted and split. See below for supported protocols. cnlohr\u0026rsquo;s version only supports \u0026ldquo;Raw\u0026rdquo;.   IP string 127.0.0.1 Valid IPs ✅ The IP to send the packets to.   Port int 7777 0~65535 ✅ The port to send the packets to.   LEDPattern string \u0026ldquo;RGB\u0026rdquo; Any valid pattern ❌ The order in which to send data for each LED. Any combination of characters R, G, B, Y is valid, in any order, including repetition. Number of characters determines how many bytes each LED takes up in the packet.   ZigZag bool false  ❌ Whether to reverse every odd line of the output for zig-zag wired LED arrays.   Mirror bool false  ❌ Whether the LED matrix wiring runs left-to-right (false) or right-to-left (true).   RotatedArray bool false  ❌ Rotates the LED data 180 degrees for an upside-down matrix.   SizeX int 1  ❌ How wide the LED matrix is. Leave as default if you\u0026rsquo;re not using a matrix, otherwise specify correctly.   SizeY int 1  ❌ How tall the LED matrix is. Leave as default if you\u0026rsquo;re not using a matrix, otherwise specify correctly.   StartIndex int 0 0~ ✅ Where in the visualizer data to start reading when putting data into the packet. Use this if you want the packet to only contain a subset of the visualizer data.   EndIndex int -1 -1~ ✅ Where in the visualizer data to stop reading when putting data into the packet. Use this if you want the packet to only contain a subset of the visualizer data. -1 means read to the end, regardless of data amount.   Enable bool true  ✅ Whether to use this output.    Configuring an LED Matrix # If you are outputting to an LED matrix, there are several options available to help you make sure the output is correct.\n❗  If you use these options, you must specify SizeX and SizeY options correctly as well.   Looking at your LED matrix from the front, match how it is wired with one of the images below to find the correct options for your setup:\n  ZigZag = false\nMirror = false\nRotatedArray = false ZigZag = false\nMirror = true\nRotatedArray = false ZigZag = false\nMirror = false\nRotatedArray = true ZigZag = false\nMirror = true\nRotatedArray = true   ZigZag = true\nMirror = false\nRotatedArray = false ZigZag = true\nMirror = true\nRotatedArray = false ZigZag = true\nMirror = false\nRotatedArray = true ZigZag = true\nMirror = true\nRotatedArray = true    Protocol-Specific Configs # Raw #    Option Name Type Default Range Controllable Description     PaddingFront int 0 0~1000 ✅ Number of padding bytes to append to the front of the packet.   PaddingBack int 0 0~1000 ✅ Number of padding bytes to append to the back of the packet.   PaddingContent int 0 0~255 ✅ What data to put in the padding bytes at the start and end, if present.    TPM2.net #    Option Name Type Default Range Controllable Description     PaddingContent int 0 0~255 ✅ What data to put in the padding bytes at the start and end, if present.   MaxPacketLength int -1 -1~65535 ❌ The maximum size of packets before splitting. -1 means use protocol specified limit (1490).   ConstantPacketLength bool false  ❌ Whether to make all packets the same size, filling blank space with PaddingContent.    E1.31 (sACN) # ❗  The maximum size of data in E1.31 is 512 bytes, which for RGB mode translates to 170 LEDs.      Option Name Type Default Range Controllable Description     Universe int 1 1~63999 ✅ The DMX universe to address packets to.   UUID hex string 9E917B13714044CFB46F7A8298692DE3 any 16-byte hex string ❌ Unique sender ID. Change this if you have multiple instances of ColorChord.NET on the network.    "}),e.add({id:15,href:"/docs/outputs/memorymap/",title:"MemoryMap",description:"Creates a non-persistent, memory-mapped file (only in RAM, not on disk), then writes the LED count and data into the file at every frame.",content:"Input Modes: Discrete 1D\nSource Code\nThis output is useful if you want unrelated processes to be able to read the data. Acts as a Windows equivalent to the SHM output of cnlohr\u0026rsquo;s ColorChord.\nThe name of the memory-mapped file will be \u0026ldquo;ColorChord.NET-[Name]\u0026rdquo;, and the created mutex will be named \u0026ldquo;ColorChord.NET-Mutex-[Name]\u0026rdquo;, where [Name] is the instance name from the configuration.\nNotes:\n Number of reading processes is not limited Timing/frame rate synchronization is not provided Reading processes should also lock the provided Mutex during data reads  Data format is:\n[uint32 LEDCount] {[uint8 R] [uint8 G] [uint8 B]} x LEDCount  Configuration #    Option Name Type Default Range Controllable Description     Type string  \u0026ldquo;MemoryMap\u0026rdquo; ❌ Required: Specifies this output type.   Name string  Any unique name ❌ Required: A unique identifier used to attach controllers.   VisualizerName string  Valid visualizer instance name ❌ Required: The Name property of the visualizer instance to attach to.   Enable bool true  ✅ Whether to output new data into the mapped file.    "}),e.add({id:16,href:"/docs/",title:"ColorChord.NET Docs",description:"",content:""}),e.add({id:17,href:"/docs/controllers/",title:"Controllers",description:"",content:""}),e.add({id:18,href:"/docs/general/",title:"General",description:"",content:""}),e.add({id:19,href:"/docs/notefinder/",title:"NoteFinder",description:"",content:""}),e.add({id:20,href:"/docs/outputs/",title:"Outputs",description:"",content:""}),e.add({id:21,href:"/docs/visualizers/",title:"Visualizers",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()